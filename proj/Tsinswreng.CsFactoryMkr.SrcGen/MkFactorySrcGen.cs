namespace Tsinswreng.CsFactoryMkr.SrcGen ;
// MkFactoryGenerator.cs
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

[Generator]
public sealed class MkFactoryGenerator : IIncrementalGenerator {
	public void Initialize(IncrementalGeneratorInitializationContext context) {
		// 1. 找出所有標了 [MkFactory] 的 partial class
		var provider = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (node, _) => node is ClassDeclarationSyntax m
												&& m.AttributeLists.Count > 0,
				transform: static (ctx, _) => GetSemanticTarget(ctx))
			.Where(static t => t is not null);

		// 2. 產生程式碼
		context.RegisterSourceOutput(
			provider.Combine(context.CompilationProvider),
			static (spc, tuple) => Execute(tuple.Left, tuple.Right, spc));
	}

	private static ClassDeclarationSyntax? GetSemanticTarget(GeneratorSyntaxContext ctx) {
		var cls = (ClassDeclarationSyntax)ctx.Node;
		foreach (var al in cls.AttributeLists) {
			foreach (var attr in al.Attributes) {
				var name = attr.Name.ToString();
				if (name == nameof(MkFactory)
					|| name.EndsWith(nameof(MkFactory)+"Attribute")
				){
					if (cls.Modifiers.Any(SyntaxKind.PartialKeyword))
						return cls;
				}
			}
		}
		return null;
	}

	private static void Execute(
		ClassDeclarationSyntax clsDecl,
		Compilation compilation,
		SourceProductionContext ctx)
	{
		try{
			var semantic = compilation.GetSemanticModel(clsDecl.SyntaxTree);
			var typeSym = semantic.GetDeclaredSymbol(clsDecl) as INamedTypeSymbol;
			if (typeSym is null) return;

			// 讀取 attribute 內容
			var attr = typeSym.GetAttributes()
						.First(ad => ad.AttributeClass?.Name == nameof(MkFactory));

			// 读取 MethodName（可能未提供）
			var methodName = "Mk";
			var mnArg = attr.NamedArguments.FirstOrDefault(kvp => kvp.Key == nameof(MkFactory.MethodName));
			if (mnArg.Key != null)
			{
				var tc = mnArg.Value;
				if (tc.Value is string s && !string.IsNullOrEmpty(s))
					methodName = s;
			}

			// 读取 IgnoredFields，TypedConstant 可以是数组或单一值
			IEnumerable<string> _ignored = Enumerable.Empty<string>();
			var ignArg = attr.NamedArguments.FirstOrDefault(kvp => kvp.Key == nameof(MkFactory.IgnoredFields));
			if (ignArg.Key != null)
			{
				var tc = ignArg.Value;
				if (tc.Kind == TypedConstantKind.Array)
					_ignored = tc.Values.Select(v => v.Value?.ToString() ?? "");
				else if (tc.Value != null)
					_ignored = new[] { tc.Value.ToString() };
			}
			var ignored = new HashSet<string>(_ignored);

			// 收集所有可寫入屬性（含繼承）
			var props = new List<IPropertySymbol>();
			CollectWritableProps(typeSym, props, ignored);

			if (!props.Any()) return;

			var ns = typeSym.ContainingNamespace.IsGlobalNamespace
					? ""
					: $"namespace {typeSym.ContainingNamespace};";

			var sb = new StringBuilder();
			sb.AppendLine("// <auto-generated />");
			sb.AppendLine(ns);
			sb.AppendLine();
			sb.AppendLine($"public partial class {typeSym.Name}");
			sb.AppendLine("{");
			sb.Append("    public static ").Append(typeSym.Name).Append(" ").Append(methodName).Append("(");
			// 參數列
			sb.Append(string.Join(", ", props.Select(p =>
				$"{p.Type.ToDisplayString()} {p.Name.ToCamelCase()}")));
			sb.AppendLine(")");
			sb.AppendLine("    {");
			sb.Append("        var r = new ").Append(typeSym.Name).AppendLine(" {");
			foreach (var p in props) {
				sb.Append("            ").Append(p.Name).Append(" = ").Append(p.Name.ToCamelCase()).AppendLine(",");
			}
			sb.AppendLine("        };");
			sb.AppendLine("        return r;");
			sb.AppendLine("    }");
			sb.AppendLine("}");

			var fileName = $"{typeSym.ContainingNamespace}.{typeSym.Name}.MkFactory.g.cs";
			ctx.AddSource(fileName, sb.ToString());
		}
		catch (System.Exception e){
			Logger.Append(e.ToString());
			throw;
		}
	}

	// 遞迴收集父類/介面可寫屬性
	private static void CollectWritableProps(
		INamedTypeSymbol? type,
		List<IPropertySymbol> bucket,
		HashSet<string> ignored) {
		if (type is null || type.SpecialType != SpecialType.None) return;

		foreach (var member in type.GetMembers().OfType<IPropertySymbol>()) {
			if (member.SetMethod is not null &&
				!member.IsStatic &&
				!ignored.Contains(member.Name) &&
				!bucket.Any(p => p.Name == member.Name)) {
				bucket.Add(member);
			}
		}

		// 先找基底類別
		CollectWritableProps(type.BaseType, bucket, ignored);
		// 再找介面
		foreach (var iface in type.Interfaces)
			CollectWritableProps(iface, bucket, ignored);
	}
}

internal static class Util {
	public static string ToCamelCase(this string src){
		//string.IsNullOrEmpty(src) ? src : char.ToLower(src[0]) + src.Substring(1);
		return src;
	}
}

